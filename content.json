[{"title":"leetcode周末算法","date":"2017-02-26T04:52:20.000Z","path":"2017/02/26/leetcode周末算法/","text":"523. Continuous Subarray Sum My SubmissionsBack To ContestDifficulty: MediumGiven a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer. Example 1:Input: [23, 2, 4, 6, 7], k=6Output: TrueExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.Example 2:Input: [23, 2, 6, 4, 7], k=6Output: TrueExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.Note:The length of the array won’t exceed 10,000.You may assume the sum of all the numbers is in the range of a signed 32-bit integer. 题目：给定一个数组nums,和一个整数k,求数组中是否存在子串之和能够整除k算法分析：利用从0到pos之和取余k的值作为标志，例如:0到2取余k值为3，0到5取余k值也为3，则说明3到5子串之和取余k为0此外要将位置0加入子串数组中，因此需要首先将标识为0序列推入下表-1，这样当0～pos取余k为0，（pos - 0 + 1）获取子串中元素个数，遍历才能拿到正确结果注意事项：对于参数k为0和负数的处理1234567891011121314151617181920212223class Solution &#123;public: bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, vector&lt;int&gt;&gt; m; int a = 0, len = nums.size(); if(k == 0)&#123; for(int i = 1;i &lt; len;i++)&#123; if(nums[i] == 0 &amp;&amp; nums[i - 1] == 0) return true; &#125; return false; &#125; k = k &gt; 0 ? k : -k; m[0].push_back(-1); for(int i = 0;i &lt; len;i++)&#123; a = (a + nums[i]) % k; m[a].push_back(i); &#125; for(auto i : m)&#123; if(i.second.size() &gt;= 2 &amp;&amp; i.second.back() - i.second[0] &gt;= 2) return true; &#125; return false; &#125;&#125;; 524. Longest Word in Dictionary through Deleting My SubmissionsBack To ContestUser Accepted: 609User Tried: 827Total Accepted: 619Total Submissions: 2039Difficulty: MediumGiven a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. Example 1:Input:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”] Output:“apple”Example 2:Input:s = “abpcplea”, d = [“a”,”b”,”c”] Output:“a”Note:All the strings in the input will only contain lower-case letters.The size of the dictionary won’t exceed 1,000.The length of all the strings in the input won’t exceed 1,000. 题目：给定字符串s，和单词字典d，将s删除部分字母可构成d中的单词，求满足条件最长的单词，当单词长度相同时，返回字典序列最小的算法分析: 贪心算法匹配s删除部分字符是否和单词匹配123456789101112131415161718192021class Solution &#123; bool check(string &amp;s, string &amp;word)&#123; int pos = 0, len = s.size(); for(auto w : word)&#123; while(pos &lt; len &amp;&amp; s[pos] != w) pos++; if(pos == len) return false; pos++; &#125; return true; &#125;public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string res = &quot;&quot;; for(auto word : d)&#123; if((res == &quot;&quot; || res.size() &lt; word.size() || (res.size() == word.size() &amp;&amp; res &gt; word)) &amp;&amp; check(s, word))&#123; res = word; &#125; &#125; return res; &#125;&#125;;","tags":[{"name":"算法","slug":"算法","permalink":"//happyeverday.github.io/tags/算法/"}]},{"title":"zoom与scale","date":"2017-02-15T12:03:52.000Z","path":"2017/02/15/zoom与scale/","text":"zoom默认以左上角为中心进行缩放，scale默认以中心进行缩放 zoom会改变页面布局，scale不改变页面布局 zoom文字受到最小中文12px的限制，而scale直接进行缩放 渲染性能，zoom会引发整个页面的重新渲染，而scale只重绘当前元素","tags":[{"name":"css3","slug":"css3","permalink":"//happyeverday.github.io/tags/css3/"}]},{"title":"C++函数lower_bound和upper_bound应用","date":"2017-01-12T07:09:08.000Z","path":"2017/01/12/lower-bound/","text":"介绍ForwardIter lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。 ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)算法返回一个非递减序列[first, last)中第一个大于val的位置。 lower_bound源码123456789101112131415161718int lower_bound(int *array, int size, int key)&#123; int first = 0, middle; int half, len; len = size; while(len &gt; 0) &#123; half = len &gt;&gt; 1; middle = first + half; if(array[middle] &lt; key) &#123; first = middle + 1; len = len-half-1; //在右边子序列中查找 &#125; else len = half; //在左边子序列（包含middle）中查找 &#125; return first;&#125; upper_bound源码12345678910111213141516int upper_bound(int *array, int size, int key)&#123; int first = 0, middle; int half, len = size; while(len &gt; 0)&#123; half = len &gt;&gt; 1; middle = first + half; if(array[middle] &gt; key)&#123; len = half; &#125; else&#123;//在右半边寻找 first = middle + 1; len = len - half - 1; &#125; &#125; return first;&#125; 应用leetcode 315. Count of Smaller Numbers After SelfYou are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Given nums = [5, 2, 6, 1] To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element.Return the array [2, 1, 1, 0].解释：对于一个给定的数组，找到每个位置右侧小于自身的元素的个数最朴素的想法:复杂度o(n^2)，遍历数组，对于每一个位置pos，遍历pos+1到最后一个元素，记录小于nums[pos]元素的数量，但是此时没有记录已比较过的元素之间的关系改进：复杂度n*log(n)，从后向前便利数组，同时维持一个生序的子序列，对于每一个位置pos，采用二分搜索返回小于nums[pos]的元素12345678910111213class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; tmp, res(len, 0); for(int i = len - 1;i &gt;= 0;i--)&#123; auto pos = lower_bound(tmp.begin(), tmp.end(), nums[i]);//找到i应该插入的位置 res[i] = pos - tmp.begin();//则前面有pos-begin个元素小于nums[i] tmp.insert(pos, nums[i]);//插入当前元素 &#125; return res; &#125;&#125; 327. Count of Range SumGiven an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note:A naive algorithm of O(n2) is trivial. You MUST do better than that. Example:Given nums = [-2, 5, -1], lower = -2, upper = 2,Return 3.The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.解释：对于一个给定的数组，求满足[a,b]区间内元素和落在lower, supper之间，求这样的区间个数12345678910111213141516class Solution &#123;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; multiset&lt;long long&gt; pSum; int res = 0, i; long long left, right, sum=0; pSum.insert(0);// 确定当sum等于supper或者lower时，有值 for(i=0; i&lt;nums.size(); ++i) &#123; sum +=nums[i]; res += distance(pSum.lower_bound(sum-upper), pSum.upper_bound(sum-lower));//以sum为结尾的区间满足条件的个数 pSum.insert(sum); &#125; return res; &#125;&#125;; 二叉搜索树解决问题327. Count of Range SumGiven an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note:A naive algorithm of O(n2) is trivial. You MUST do better than that. Example:Given nums = [-2, 5, -1], lower = -2, upper = 2,Return 3.The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.解释：对于一个给定的数组，求满足[a,b]区间内元素和落在lower, supper之间，求这样的区间个数最朴素的想法：复杂度o(n^2),对于位置pos,分别计算从0-pos起始得到的和是否落在lower到upper区间内改进:记录从0到pos的和升序数组，当计算以pos+1为结尾的部分数组构成落在lower到upper区间内的和个数时，只需要将当前0到pos+1的元素和减去从0到位置j的元素和，要求满足剩余部分j+1到pos+1的元素和落在lower道upper区间内，所以要求从0-j的元素和在sum - lower到sum-upper区间内，生序和数组遍历时可采用二叉搜索。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;private: class BSTNode&#123; // Binary search tree implementation public: long long val; int cnt; // how many nodes with value of &quot;val&apos; int lCnt; // how many nodes on its left subtree BSTNode *left; BSTNode *right; BSTNode(long long x) &#123; val = x; cnt = 1; lCnt = 0; left = right = nullptr; &#125; &#125;; int getBound(BSTNode *root, long long x, bool includeSelf) &#123; // get the index of the last node that satisfy val&lt;x (includeSelf=false) or val&lt;=x (includeSelf = true) if(!root) return 0; if(root-&gt;val == x) return root-&gt;lCnt + (includeSelf?root-&gt;cnt:0); else if(root-&gt;val &gt; x) return getBound(root-&gt;left, x, includeSelf); else return root-&gt;cnt + root-&gt;lCnt + getBound(root-&gt;right, x, includeSelf); &#125; void insert(BSTNode*&amp; root, long long x) &#123; // insert a node to the tree if(!root) root = new BSTNode(x); else if(root-&gt;val == x) (root-&gt;cnt)++; else if(root-&gt;val &lt; x) insert(root-&gt;right,x); else&#123; ++(root-&gt;lCnt); insert(root-&gt;left,x); &#125; &#125; void deleteTree(BSTNode*root) &#123; //destroy the tree if(!root) return; deleteTree(root-&gt;left); deleteTree(root-&gt;right); delete root; &#125; public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; // same idea as the multiset version BSTNode *root= new BSTNode(0); int res = 0, i; long long left, right, sum=0; for(i=0; i&lt;nums.size(); ++i) &#123; sum +=nums[i]; res += getBound(root, sum-lower, true) - getBound(root, sum-upper, false); insert(root, sum); &#125; deleteTree(root); return res; &#125;&#125;;","tags":[{"name":"算法","slug":"算法","permalink":"//happyeverday.github.io/tags/算法/"}]},{"title":"cssSelectorPriority","date":"2017-01-10T06:52:43.000Z","path":"2017/01/10/cssSelectorPriority/","text":"选择器特殊性 內联样式，1000 给定ID属性值，加0100 给定类属性值，属性选择或者伪类，加0010 给定元素或者伪元素，加0001 结合符和通用匹配符特殊性为0000 重要声明!important标志放在声明的最后面，重要声明与非重要声明发生冲突时永远是重要声明胜出 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #test&#123; color: red; &#125; p[id=\"test\"]&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=\"test\"&gt; id选择器与id属性选择器优先级不同 #test 0100 p[id=\"test\"] 0011 最终呈现为红色 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 继承 有些属性不能继承，外边距，内边距，背景和边框等 继承的值无特殊性，tips：0000与没有特殊性是有差别的，因此当继承值与*比较时，通用匹配符胜出 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p&#123; color: black; &#125; *&#123; color: grey; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;black &lt;em&gt;grey&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 层叠 找出元素所有相关规则 按显示权重排序 读者!important声明 作者！important声明 作者正常声明 读者正常声明 代理默认样式 按照特殊性排序，如果多个声明的权重相同，则按照特殊性排序 按照出现顺序排序，一般认为导入样式表出现在前面，主样式表出现在后面","tags":[{"name":"css3","slug":"css3","permalink":"//happyeverday.github.io/tags/css3/"}]},{"title":"css3选择器总结","date":"2017-01-09T05:10:29.000Z","path":"2017/01/09/css3-selector/","text":"写在前面总结一下css选择器啦～有点长😳，下面是目录1.元素选择器 Element Selectors2.关系选择符 Relationship Selectors3.属性选择符 Attribute Selectors4.伪类选择符 Pseudo-Classes Selectors5.伪元素选择符 Pseudo-Element Selectors 1.Element Selectors12341. 通用选择符 *&#123;&#125;2. 类型选择符 E&#123;&#125;3. id选择符 E#id&#123;&#125;4. class选择符 E.class&#123;&#125; 2.Relationship Selectors12345678910111213141516171819201. 包含选择符 E F2. 子元素选择符 E &gt; F3. 相邻元素选择符 E + F //符合条件的相邻兄弟元素，注意两个元素之间的文本内容不会影响兄弟选择符起作用的，中间的文本不包含在兄弟元素中，而是父元素的一部分&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p + p&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;1&lt;/p&gt; 中间的文本 &lt;p&gt;我还是会显示成红色&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;4. 兄弟选择符 E ~ F //命中所有符合条件的兄弟元素，而不仅仅是相邻元素，css3中出现的 3.Attribute Selectors1.选择具有attr属性的元素1E[attr]&#123;&#125; 2.具有attr属性，且值为val的元素12345678910111213141516E[attr=\"val\"]&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p[class=\"a b\"] p[class=\"a\"]&#123; /*不能匹配class=\"a b\"的元素，=匹配要求完全相等*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"a b\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.具有attr属性，且属性值为空格分割的单词列表，列表中包含val123456789101112131415p[class=\"val\"]&lt;!-- 示例 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p[class~=\"a\"] &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"a b\"&gt;&lt;/p&gt; &lt;p class=\"a\"&gt;我也可以被匹配😄&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4.具有attr属性，并且以val开头,结尾，包含,css3新增属性123p[class^=&quot;val&quot;]p[class$=&quot;val&quot;]p[class*=&quot;val&quot;] 5.选择属性值为val，以及以val-开头的元素1p[class|=&quot;val&quot;] 4.Pseudo-Classes Selectors1.链接伪类12345678910111213141516&lt;!--链接a未被访问之前的样式--&gt;E:link&lt;!--已经被访问过--&gt;E:visited&lt;!--鼠标悬停样式--&gt;E:hover&lt;!--用户激活，发生在鼠标点击和鼠标释放之间的事件，在hover后发生--&gt;E:active&lt;!--称为输入焦点时的样式，对应事件onfocus--&gt;E:focus&lt;!--超链接状态顺序，love+hate--&gt;a:link&#123;&#125;a:visited&#123;&#125;a:hover&#123;&#125;a:active&#123;&#125; 2.匹配特定语言123E:lang(fr)&lt;!--示例，匹配语言为english的p元素--&gt;p:lang(english)&#123;&#125; 3.not选择符12345E:not(s)&lt;!--示例，匹配非最后一个li元素--&gt;li:not(:last-child)&#123;border:1px solid black&#125; 4.匹配根元素，html中根元素永远是html1E:root 5.*-child 要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是body，即E可以是body的子元素 父元素的第一个子元素为E才能匹配，即匹配作为第一个子元素的E元素 E:nth-child(n)会选择父元素的第n个子元素E，如果第n个子元素不是E，则是无效选择符，但n会递增。 123456789101112131415161718192021222324252627282930E:first-childE:last-childE:only-childE:nth-child(n)E:nth-last-child(n)&lt;!--示例1--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;我是第一个元素&lt;/div&gt; &lt;p&gt;我不能被p:first-child匹配到&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--示例2--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;我不能被div:first-child匹配到,伪类前面的标签，E指的是子元素的类型&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.*-of-type 要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是html，即E可以是html的子元素，也就是说E可以是body 可以选中第一个E元素，无论父元素的第一个子元素是否伪E，注意与:first-child的区别 12345E:first-of-typeE:last-of-typeE:only-of-typeE:nth-of-type(n)E:nth-last-of-type(n) 7.杂项1234567891011121314&lt;!--没有任何子元素（包括text元素,不包括comment元素）--&gt;E:empty&lt;!--被选中--&gt;E:checked&lt;!--可用状态--&gt;E:enabled&lt;!--备用状态--&gt;E:disabled&lt;!-- 匹配url #指向的E元素 --&gt;E:target&lt;!--打印时页面容器的样式--&gt;@page:first@page:left@page:right 5.Pseudo-Element Selectors1.::first-letter,::first-line 只对块级元素有效 12345678910111213141516&lt;!--示例--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p::first-letter, span::first-letter&#123; font-size: 2em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;first-letter,span元素无效&lt;/span&gt; &lt;p&gt;first-letter，f字号增大&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.E::before{} E::after{} 不设置content属性无效 默认盒模型为inline-box，通常为了能给伪元素赋予高度，边框等内容，将display设置为block 伪元素插入的位置，成为关联目标元素的字元素，放置在这个元素内容的前面或者后面 插入元素不是真正的元素，不能用js操作 插入内容 文本 content: ‘’ 元素属性 content: attr() 图片 content: url() 技术器 content: counter() 应用 img破损时，显示默认信息 创建边框效果等 12345678910111213141516171819202122&lt;!-- 示例 ，before和after的位置--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .choosen&#123; width: 100px; height: 100px; border: 1px solid black; &#125; .choosen::before&#123; content: 'before'; display: block; border: 1px solid pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"choosen\"&gt;原有内容,::before显示在div内部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.css3新增 E::placeholder{} E::selection{} 占位符伪对象 需要注意的是，::selection只能定义被选择时的background-color，color及text-shadow 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; input::-webkit-input-placeholder &#123; color: green; &#125; input:-ms-input-placeholder &#123; // IE10+ color: green; &#125; input:-moz-placeholder &#123; // Firefox4-18 color: green; &#125; input::-moz-placeholder &#123; // Firefox19+ color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" placeholder=\"占位符\" /&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"css3","slug":"css3","permalink":"//happyeverday.github.io/tags/css3/"}]},{"title":"2017,启航","date":"2017-01-06T06:20:23.000Z","path":"2017/01/06/start/","text":"写在前面第一篇博客破壳日，顺路记录下hexo+github搭建个人博客过程 hexo+github搭建个人博客步骤Step1.安装hexo1$ npm install hexo-cli -g Step2.初始化博客12$ hexo init blog$ cd blog Step3.愉快的让你的博客跑起来吧，对，就是如丝般顺滑1$ hexo server 执行命令后访问 //localhost:4000,瞬间成就感爆棚有木有哇！ Step4.创建一篇新文章吧1hexo new &quot;helloWorld&quot; 命令执行完,/source/_posts/目录下已经又了helloWorld.md了，对吧。然后愉快的写啊写。。。 Step5.生成静态文件依旧没什么难点，执行一下命令即可 1hexo generator 等等，我的聪明智慧可是要影响宇宙的，怎么能局限于localhost！好吧，配置下github吧～（先得去您的github上创建一个名为github用户名.io.git的仓库哦～） Step6.配置github在根目录的_config.yml文件下，修改配置 1234deploy: type: git repo: https://github.com/你的github用户名/你的github用户名.github.io.git branch: master Step7.发布到github1hexo deploy 什么，居然出现了错误信息,好气啊 1&apos;git&apos; does not appear to be a git repository 哦，原来是还需要安装个hexo-deployer-git，好吧，那就安装呗 1$ npm install hexo-deployer-git --save 安装完成后，再重新执行hexo deploy命令呗，访问 //你的github用户名.github.io 就可以看到新鲜出炉的博客喽～ 番外：更换hexo主题不喜欢默认的landscape主题怎么办？换呗！找啊找，找到了这篇主题贴有哪些好看的Hexo主题，都好漂亮，好满意有木有我是用的是yilia主题，具体配置作者在github上讲的很详细主要就是clone主题+选中主题+配置主题 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml ： theme: yilia 修改themes/yilia/目录下的_config.xml,想怎么配置怎么配置喽～","tags":[{"name":"hexo","slug":"hexo","permalink":"//happyeverday.github.io/tags/hexo/"}]},{"title":"函数去抖与函数节流","date":"2016-11-23T07:08:52.000Z","path":"2016/11/23/函数去抖与函数节流/","text":"#1. 函数去抖应用场景：联想词推荐方法：设置定时器，当限定时间内，事件重复触发时，清零计时器，当事件不再触发，执行函数 123456function debounce(method, delay)&#123; if(method.tId)&#123; clearTimeOut(method.tId) &#125; method.tId = setTimeOut(method, delay);&#125; #2. 函数节流应用场景：scroll resize事件方法：设定函数执行的最小时间间隔，事件处理函数至少delay时间内调用一次，降低函数调用频率12345678910111213141516function throttle(method, delay)&#123; let previous = 0, timeout = null; return function()&#123; let now = new Date().getTime(), remain = delay - (now - previous); if(remain &lt;= 0)&#123; if(timeout) clearTimeOut(timeout);//清空计时器 timeout = null; previous = now;//更新上次调用时间 method() &#125; else if(!timeout)&#123; timeout = setTimeOut(method, remain); &#125; &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"//happyeverday.github.io/tags/javascript/"}]}]